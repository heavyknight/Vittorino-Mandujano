#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctime>
#include <omp.h>
#define N 2000

void generar(int**);

int filtro(int**,int,int);

// Version 16

int main(int argc, char* argv[]){
    
    int hilos;
    double t=0.0;
    int **A, **B;
    
    A = new int* [N];
    B = new int* [N];
    
    for(int i=0;i<N;i++){
        A[i] = new int[N];
        B[i] = new int[N];
    }
    
    hilos = strtol(argv[1],NULL,10);
    
    srand(time(0));
    generar(A);
    
    
    for(int i=0;i<N;i++){
        for(int j=0;j<N;j++)
            B[i][j]=0;
    }
    
    //mostrando A
    for(int i=0;i<10;i++){
        for(int j=0;j<10;j++){
            printf(" %d ",A[i][j]);
        }
        printf("\n");
    }
    
    //calculando B
    t=omp_get_wtime();
    //t=time(0);
    //================================================================================
    // MI PROGRAMA VERGONZOSAMENTE PARALELO
    //================================================================================
    #pragma omp parallel  num_threads(hilos)
    {
        int w[5][5]={{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}};
        #pragma omp for
        for(int x=2;x<N-2;x++)
            for(int y=2;y<N-2;y++){
                B[x][y] =  ( w[0][0]*A[x-2][y-2] +w[0][1]*A[x-2][y-1] +w[0][2]*A[x-2][y] +w[0][3]*A[x-2][y+1] +w[0][4]*A[x-2][y+2] \
                            +w[1][0]*A[x-1][y-2] +w[1][1]*A[x-1][y-1] +w[1][2]*A[x-1][y] +w[1][3]*A[x-1][y+1] +w[1][4]*A[x-1][y+2] \
                            +w[2][0]*A[x][y-2]   +w[2][1]*A[x][y-1]   +w[2][2]*A[x][y]   +w[2][3]*A[x][y+1]   +w[2][4]*A[x][y+2]   \
                            +w[3][0]*A[x+1][y-2] +w[3][1]*A[x+1][y-1] +w[3][2]*A[x+1][y] +w[3][3]*A[x+1][y+1] +w[3][4]*A[x+1][y+2] \
                            +w[4][0]*A[x+2][y-2] +w[4][1]*A[x+2][y-1] +w[4][2]*A[x+2][y] +w[4][3]*A[x+2][y+1] +w[4][4]*A[x+2][y+2] \
                            )/25;
            }

            
        #pragma omp for
        for(int y=2;y<N-2;y++){
            B[1][y] = ( +w[1][0]*A[0][y-2] +w[1][1]*A[0][y-1] +w[1][2]*A[0][y] +w[1][3]*A[0][y+1] +w[1][4]*A[0][y+2] \
                        +w[2][0]*A[1][y-2] +w[2][1]*A[1][y-1] +w[2][2]*A[1][y] +w[2][3]*A[1][y+1] +w[2][4]*A[1][y+2] \
                        +w[3][0]*A[2][y-2] +w[3][1]*A[2][y-1] +w[3][2]*A[2][y] +w[3][3]*A[2][y+1] +w[3][4]*A[2][y+2] \
                        +w[4][0]*A[3][y-2] +w[4][1]*A[3][y-1] +w[4][2]*A[3][y] +w[4][3]*A[3][y+1] +w[4][4]*A[3][y+2] \
                        )/20;
        }
        
        #pragma omp for
        for(int y=2;y<N-2;y++){             
            B[1998][y] = (  +w[0][0]*A[1996][y-2] +w[0][1]*A[1996][y-1] +w[0][2]*A[1996][y] +w[0][3]*A[1996][y+1] +w[0][4]*A[1996][y+2] \
                            +w[1][0]*A[1997][y-2] +w[1][1]*A[1997][y-1] +w[1][2]*A[1997][y] +w[1][3]*A[1997][y+1] +w[1][4]*A[1997][y+2] \
                            +w[2][0]*A[1998][y-2] +w[2][1]*A[1998][y-1] +w[2][2]*A[1998][y] +w[2][3]*A[1998][y+1] +w[2][4]*A[1998][y+2] \
                            +w[3][0]*A[1999][y-2] +w[3][1]*A[1999][y-1] +w[3][2]*A[1999][y] +w[3][3]*A[1999][y+1] +w[3][4]*A[1999][y+2] \
                            )/20;       
        }
        
        
        #pragma omp for
        for(int x=2;x<N-2;x++){
                B[x][1] =  ( w[0][1]*A[x-2][0] +w[0][2]*A[x-2][1] +w[0][3]*A[x-2][2] +w[0][4]*A[x-2][3] \
                            +w[1][1]*A[x-1][0] +w[1][2]*A[x-1][1] +w[1][3]*A[x-1][2] +w[1][4]*A[x-1][3] \
                            +w[2][1]*A[x][0]   +w[2][2]*A[x][1]   +w[2][3]*A[x][2]   +w[2][4]*A[x][3]   \
                            +w[3][1]*A[x+1][0] +w[3][2]*A[x+1][1] +w[3][3]*A[x+1][2] +w[3][4]*A[x+1][3] \
                            +w[4][1]*A[x+2][0] +w[4][2]*A[x+2][1] +w[4][3]*A[x+2][2] +w[4][4]*A[x+2][3] \
                            )/20;
            }
        
        #pragma omp for
        for(int x=2;x<N-2;x++){
                B[x][1998] =  (  w[0][0]*A[x-2][1996] +w[0][1]*A[x-2][1997] +w[0][2]*A[x-2][1998] +w[0][3]*A[x-2][1999] \
                                +w[1][0]*A[x-1][1996] +w[1][1]*A[x-1][1997] +w[1][2]*A[x-1][1998] +w[1][3]*A[x-1][1999] \
                                +w[2][0]*A[x][1996]   +w[2][1]*A[x][1997]   +w[2][2]*A[x][1998]   +w[2][3]*A[x][1999] \
                                +w[3][0]*A[x+1][1996] +w[3][1]*A[x+1][1997] +w[3][2]*A[x+1][1998] +w[3][3]*A[x+1][1999] \
                                +w[4][0]*A[x+2][1996] +w[4][1]*A[x+2][1997] +w[4][2]*A[x+2][1998] +w[4][3]*A[x+2][1999] \
                                )/20;
            }
        
        //===============================================================================================================
        
        #pragma omp for
        for(int y=2;y<N-2;y++){
                B[0][y] =  (+w[2][0]*A[0][y-2] +w[2][1]*A[0][y-1] +w[2][2]*A[0][y] +w[2][3]*A[0][y+1] +w[2][4]*A[0][y+2] \
                            +w[3][0]*A[1][y-2] +w[3][1]*A[1][y-1] +w[3][2]*A[1][y] +w[3][3]*A[1][y+1] +w[2][4]*A[1][y+2] \
                            +w[4][0]*A[3][y-2] +w[4][1]*A[3][y-1] +w[4][2]*A[3][y] +w[4][3]*A[3][y+1] +w[2][4]*A[3][y+2] \
                            )/15;
            }
        
        #pragma omp for
        for(int y=2;y<N-2;y++){
                B[1999][y] =  ( +w[0][0]*A[1997][y-2] +w[0][1]*A[1997][y-1] +w[0][2]*A[1997][y] +w[0][3]*A[1997][y+1] +w[0][4]*A[1997][y+2] \
                                +w[1][0]*A[1998][y-2] +w[1][1]*A[1998][y-1] +w[1][2]*A[1998][y] +w[1][3]*A[1998][y+1] +w[1][4]*A[1998][y+2] \
                                +w[2][0]*A[1999][y-2] +w[2][1]*A[1999][y-1] +w[2][2]*A[1999][y] +w[2][3]*A[1999][y+1] +w[2][4]*A[1999][y+2] \
                              )/15;
            }
        


        #pragma omp for
        for(int x=2;x<N-2;x++){
                B[x][0] =  ( w[0][0]*A[x-2][0] +w[0][1]*A[x-2][1] +w[0][2]*A[x-2][2] \
                            +w[1][0]*A[x-1][0] +w[1][1]*A[x-1][1] +w[1][2]*A[x-1][2] \
                            +w[2][0]*A[x][0]   +w[2][1]*A[x][1]   +w[2][2]*A[x][2]   \
                            +w[3][0]*A[x+1][0] +w[3][1]*A[x+1][1] +w[3][2]*A[x+1][2] \
                            +w[4][0]*A[x+2][0] +w[4][1]*A[x+2][1] +w[4][2]*A[x+2][2] \
                            )/15;
            }
        
        #pragma omp for
        for(int x=2;x<N-2;x++){
                B[x][1999] =  (  w[0][2]*A[x-2][1997] +w[0][3]*A[x-2][1998] +w[0][4]*A[x-2][1999] \
                                +w[1][2]*A[x-1][1997] +w[1][3]*A[x-1][1998] +w[1][4]*A[x-1][1999] \
                                +w[2][2]*A[x][1997]   +w[2][3]*A[x][1998]   +w[2][4]*A[x][1999] \
                                +w[3][2]*A[x+1][1997] +w[3][3]*A[x+1][1998] +w[3][4]*A[x+1][1999] \
                                +w[4][2]*A[x+2][1997] +w[4][3]*A[x+2][1998] +w[4][4]*A[x+2][1999] \
                                )/15;
            }
        

        
        #pragma omp for
        for(int i=0;i<2;i++)
            for(int j=0;j<2;j++){
                B[i][j]=filtro(A,i,j);
                B[i][j+1998]=filtro(A,i,j+1998);
                B[i+1998][j]=filtro(A,i+1998,j);
                B[i+1998][j+1998]=filtro(A,i+1998,j+1998);
            }
            
    }
    
    t=omp_get_wtime()-t;
    //t=time(0)-t;
    
    //mostrando B
    printf("\n");
    printf("\n");
    for(int i=0;i<10;i++){
        for(int j=0;j<10;j++){
            printf(" %d ",B[i][j]);
        }
        printf("\n");
    }
    
    // Eliminando matrices
    for(int i=0;i<N;i++){
        delete[] A[i];
    }
    for(int i=0;i<N;i++){
        delete[] B[i];
    }
    delete[] A;
    delete[] B;
    
    printf("tiempo de ejecucion %lf \n",t);
    
    return 0;   
    
}

void generar(int** m){
    srand(time(0));
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++){
            m[i][j]=rand()%10;
            //m[i][j]=1;
        }
}

int filtro(int** m,int x,int y){
    int w[5][5]={{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}};
    int x_i,x_f,y_i,y_f,z;
    
    x_i=-2;
    x_f=2;
    y_i=-2;
    y_f=2;
    z=0;
    
    switch(x){
        case 0: x_i=0;break;
        case 1: x_i=-1;break;
        case 1998: x_f=1;break;
        case 1999: x_f=0;break;
    }
    
    switch(y){
        case 0: y_i=0;break;
        case 1: y_i=-1;break;
        case 1998: y_f=1;break;
        case 1999: y_f=0;break;
    }
    
    for(int i=x_i;i<=x_f;i++){
        for(int j=y_i;j<=y_f;j++){
            z+=m[x+i][y+j]*w[i+2][j+2];
            //z+=m[x+i][y+j];
        }
    }
    z=z/((x_f + 1- x_i)*(y_f + 1  - y_i));
    return z;
}